Goals:

Rely on the C++ standard to provide platform-independence, because the
C++ standard will work on future platforms without requiring
source-code changes. This means:

* Using C++ functionality rather than POSIX or Windows functionality.

* Choosing a specific C++ standard , and then
specifying that standard to the compiler.


* Remove as many \#ifdef preprocess directives as possible.

* Replacing code that we had painstakingly written, debugged and
maintained with code now supported in the C++ standard

We originally chose C++14 but changed to C++17 to get the
std::filesystem support.


Dramatically improve reliability. This means:
* Whereas previously many strings were passed by reference as 'const std::string &',
there are now passed by value 'std::string'. This necessitates a
string copy, but it is not a meaningful impact on performance,
especially when compared with the improved safety against possibly
using an invalidated reference.

* we defined a clear allocation/deallocation policy for all
objects in memory, especially the sbuf objects.

* We enabled sbuf child tracking. Previously this was turned off
because of an underlying memory allocation bug. Once we defined the
clear policy described above, we were able to find the bug!

* Unit tests and code-coverage, rather than simply end-to-end
regression tests.

* Moved more functionality into the sbuf_t structure, such as
computing the hash of an sbuf. We also now cache the hash, so we are
assured that each block of data will only be hashed once.


Code Quality Goals:
* Significantly reduce the size of the bulk_extractor code base.
* Eliminate global variables used to track state. (Global variables
used to implement static tables and data-driven functions were allowed
to persist, although the code that uses these variables now checks to
verify that they have been initialized and throws an exception if they
have not.)
* Removal of return codes that must be checked to detect
errors. Instead, we use the C++ exception mechanism to signal and
catch error conditions.
* Elimination of explicit mutexs when possible, replaced with the C++
atomic template.

Performance Goals:
* Run twice as fast as the original bulk_extractor when compiled with
the same (modern) compiler with the same number of cores.
* Be able to run on a cluster with a high-performance storage system,
such as Amazon EBS or S3, and process with Amazon Lambda, with the
goal of being able to process a terabyte reference disk image in 5
minutes.

Functionality Goals:
* Link with The Sleuth Kit and automatically process non-contiguous
files if the file system is intact. Automatically report features by
both location on the disk and the file in which they are found. We did
this in a backwards compatiable manner by adding an addition field to
the pos0_t record.
(requires an additional field be added to the feature file).

* Removing the dependence on Java for the user interface.
